function a(){return new Promise((r,t)=>{const e=self.indexedDB.open("kv-storage:default",1);e.onsuccess=()=>r(e.result),e.onerror=()=>t(e.error),e.onupgradeneeded=()=>e.result.createObjectStore("store")})}function i(r){return new Promise((t,e)=>{r.oncomplete=()=>t(),r.onabort=()=>e(r.error),r.onerror=()=>e(r.error)})}function c(r,t){return new Promise((e,n)=>{r.onsuccess=()=>e(t?t(r.result):r.result),r.onerror=()=>n(r.error)})}function l(r,t){return c(r.openCursor(t),e=>e?[e.key,e.value]:[])}async function s(r,t,e){const n=r.transaction("store",t),o=n.objectStore("store");return e(n,o)}let d=null;export class JSONStore extends EventTarget{constructor(){return super(),d??=this}async set(r,t){const e=await a();await s(e,"readwrite",(n,o)=>(o.put(JSON.stringify(t),r),i(n))),this.dispatchEvent(new Event("change")),e.close()}async get(r){const t=await a(),e=await s(t,"readonly",(n,o)=>c(o.get(r)));return t.close(),e?JSON.parse(e):null}async has(r){return!!this.get(r)}async remove(r){const t=await a();await s(t,"readwrite",(e,n)=>(n.delete(r),i(e))),this.dispatchEvent(new Event("change")),t.close()}async*[Symbol.asyncIterator](){let r=-Infinity;const t=await a();do{let[e,n]=await s(t,"readonly",(o,u)=>l(u,IDBKeyRange.lowerBound(r,!0)));if(r=e,e===void 0)break;yield[e,JSON.parse(n)]}while(!0);t.close()}entries(){return this[Symbol.asyncIterator]()}}
